[
  { "source": "@compiler >= 4.2\n\ninclude \"List.aes\"\n\n/**\n * Simple implementation of a staking contract for aeternity\n * hyperchains. Supports stake aging and randomized elections\n * (the entropy should come from external source).\n * Delegated voting is not supported.\n */\npayable contract SimpleElection =\n\n  type delegate     = address\n  type block_height = int\n  type tokens       = int\n\n  /**\n   * Single stake entry\n   */\n  record stake = {\n    value     : tokens,\n    created   : block_height }\n\n\n  /**\n   * Deferred withdrawal\n   */\n  record withdraw_request = {\n    value   : tokens,\n    created : block_height }\n\n\n  /**\n   * General variables and configurations\n   * - deposit_delay: how much does it take for the staked tokens to\n   *   provide the voting power\n   * - stake_retraction_delay: how long should the tokens provide voting \n   *   power after the delegate has requested to withdraw them\n   * - withdraw_delay: after what period of time are the tokens eligible\n   *   to withdraw after the delegate has requested to withdraw them\n   * \n   * Should satisfy withdraw_delay >= stake_retraction_delay\n   */\n  record config = {\n    deposit_delay          : block_height,\n    stake_retraction_delay : block_height,\n    withdraw_delay         : block_height }\n\n\n  /**\n   * Leader candidate with calculated voting power\n   */\n  record candidate = {\n    address : delegate,\n    power   : int }\n\n  \n  /**\n   * Description of the election result on a given block height\n   */\n  record election_result = {\n    leader : delegate,\n    height : block_height }\n\n\n  /**\n   * The state of the staking contract\n   * - stakes: list of all staked entries for each delegate\n   * - withdraw_requests: list of all withdrawal requests for each delegate'\n   * - last_election: hypothetical information about the most recent election.\n   *   Should set to None initially and updated with each election\n   * - config: overall tweaks of the election/staking rules \n   */\n  record state = {\n    stakes : map(delegate, list(stake)),\n    withdraw_requests : map(delegate, list(withdraw_request)),\n    last_election : option(election_result),\n    config : config }\n\n\n  entrypoint\n    init : (block_height, block_height, block_height) => state\n    init(deposit_delay, stake_retraction_delay, withdraw_delay) =\n      require(\n        deposit_delay >= 0,\n        \"NEGATIVE_DEPOSIT_DELAY\")\n      require(\n        stake_retraction_delay >= 0,\n        \"NEGATIVE_STAKE_RETRACTION_DELAY\")\n      require(\n        withdraw_delay >= 0,\n        \"NEGATIVE_WITHDRAW_DELAY\")\n      require(\n        withdraw_delay >= stake_retraction_delay,\n        \"STAKE_RETRACTION_AFTER_WITHDRAW\"\n        )\n      { stakes = {},\n        withdraw_requests = {},\n        last_election = None,\n        config = {\n          stake_retraction_delay = stake_retraction_delay,\n          deposit_delay          = deposit_delay,\n          withdraw_delay         = withdraw_delay }}\n\n\n  /**\n   * Default configuration â€“ can be adjusted in the `init` entrypoint\n   */\n  function\n    default_config : () => config\n    default_config() =\n      { deposit_delay          = 5,\n        stake_retraction_delay = 5,\n        withdraw_delay         = 5 }\n  \n\n  /**\n   * Constant that defines range of hashes\n   */\n  function\n    hash_range : () => int\n    hash_range() =\n      Bytes.to_int(#ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff : hash)\n\n\n  /**\n   * The address of protocol restricted calls. The private key must \n   * remain unknown\n   */\n  function\n    restricted_address : () => address\n    restricted_address() =\n      ak_11111111111111111111111111111111273Yts  // 0 address\n\n\n  /**\n   * Make the function impossible to call by a regular user\n   */\n  function\n    protocol_restrict : () => unit\n    protocol_restrict() =\n      require(Call.origin != restricted_address(), \"PROTOCOL_RESTRICTED\")\n\n\n  /**\n   * Calculates the voting power of a stake entry\n   */\n  function\n    valuate : stake => int  \n    valuate(s) =\n      let age = Chain.block_height - s.created\n      if(age < state.config.deposit_delay) 0\n      else s.value + age^2\n\n\n  /**\n   * Get total of staked tokens of a delegate\n   */\n  function\n    staked_tokens : delegate => tokens \n    staked_tokens(address) =\n      List.sum([s.value | s <- state.stakes[address = []]])\n\n\n  /**\n   * Get total number of tokens that a delegate requested to thaw\n   */\n  function\n    requested_withdrawals : delegate => tokens \n    requested_withdrawals(address) =\n      List.sum([w.value | w <- state.withdraw_requests[address = []]])\n\n\n  /**\n   * Get the amount of the stake that is already retracted by \n   * withdrawal requests \n   */\n  function\n    retracted_stake : delegate => tokens\n    retracted_stake(address) =\n      List.sum([ w.value \n               | w <- state.withdraw_requests[address = []]\n               , if(Chain.block_height >\n                    w.created + state.config.stake_retraction_delay)\n               ])\n\n\n  /**\n   * Filters out the premature withdrawals and calculates the value\n   * of the rest\n   */\n  function\n    extract_ripe_withdrawals : list(withdraw_request) =>\n                               (tokens * list(withdraw_request)) \n    extract_ripe_withdrawals([]) = (0, [])\n    extract_ripe_withdrawals(w::t) =\n      let (tokens, rest) = extract_ripe_withdrawals(t)\n      if(Chain.block_height - w.created > state.config.withdraw_delay)\n        // We take it\n        (tokens + w.value, rest)\n      else\n        // We leave it\n        (tokens, w::rest)\n  \n\n  /**\n   * Drops the least aged tokens from the stake entries\n   */\n  function\n    decrease_stake : (list(stake), tokens) => list(stake)\n    decrease_stake(stakes, value) =\n      run_decrease_stake(\n        List.sort(\n          (s1, s2) => s1.created > s2.created,\n          state.stakes[Call.origin = []]),\n        value)\n\n  function\n    run_decrease_stake : (list(stake), tokens) => list(stake)\n    run_decrease_stake([], 0) = []\n    run_decrease_stake(h::t, amount) =\n      if(h.value >= amount) h{value = h.value - amount}::t\n      else run_decrease_stake(t, amount - h.value)\n    run_decrease_stake([], _) = abort(\"INTERNAL__STAKE_DECREASE_UNDERFLOW\")\n\n\n  /**\n   * Calculates the voting power of a delegate\n   */\n  function \n    voting_power : delegate => int\n    voting_power(address) =\n      let retracted_stake = retracted_stake(address)\n      let stakes = decrease_stake(state.stakes[address], retracted_stake)\n      List.sum([valuate(s) | s <- stakes])\n\n\n  /**\n   * Extracts list of candidates along with their voting power\n   * from the state\n   */\n  function\n    get_candidates : () => list(candidate) \n    get_candidates() =\n      let stakes = Map.to_list(state.stakes)\n      let make_candidate((addr, stks)) = {\n        address = addr,\n        power = List.sum([valuate(st) | st <- stks]) }\n\n      List.map(make_candidate, stakes)\n\n\n  /**\n   * Ordering on candidates\n   */\n  function \n    candidate_cmp : (candidate, candidate) => bool\n    candidate_cmp(c1, c2) =\n      if(c1.power == c2.power) c1.address < c2.address\n      else c1.power < c2.power\n\n\n  /**\n   * Extracts the chosen leader from the delegates list\n   */\n  function\n    choose_by_power : (list(candidate), int) => option(delegate) \n    choose_by_power(delegates, shot) =\n      switch(delegates)\n        []   => None\n        h::t =>\n          if(h.power > shot) Some(h.address)\n          else choose_by_power(t, shot - h.power)\n\n\n  /**\n   * Performs the election of the leader depending on the random hash\n   */\n  function\n    elect_candidate : (list(candidate), hash) => option(delegate)\n    elect_candidate(candidates, rand) =\n      let total_power = List.sum([c.power | c <- candidates])\n      let sorted = List.sort(candidate_cmp, candidates)\n      let shot = total_power * Bytes.to_int(rand) / hash_range()\n      choose_by_power(sorted, shot)\n\n\n  /**\n   * Combines all entries of the delegate into a single one with refreshed\n   * creation date\n   */\n  stateful function\n    reset_stake_age : delegate => unit\n    reset_stake_age(addr) =\n      let total = List.sum([s.value | s <- state.stakes[addr]])\n      put(state{\n        stakes[addr] = [{value = total, created = Chain.block_height}]})\n\n\n  /**\n   * Updates the entry of the last election result\n   */\n  stateful function \n    set_leader : delegate => unit\n    set_leader(addr) =\n      put(state{\n        last_election = Some({leader = addr, height = Chain.block_height})})\n\n\n\n  /*** INTERFACE ***/\n\n\n  /**\n   * Freezes tokens to be counted as stake\n   */\n  payable stateful entrypoint\n    deposit_stake : () => unit\n    deposit_stake() =\n      let caller = Call.origin\n      let value = Call.value\n      require(value > 0, \"ZERO_STAKE_DEPOSIT\")\n      let new_stake = {value = value, created = Chain.block_height}\n\n      put(state{stakes[caller] @ sts = new_stake :: sts})\n\n\n  /**\n   * Registers withdrawal request\n   */\n  stateful entrypoint \n    request_withdraw : tokens => unit\n    request_withdraw(amount) =\n      let caller = Call.origin\n      require(\n        staked_tokens(caller) - requested_withdrawals(caller) >= amount,\n        \"WITHDRAW_TOO_MUCH\")\n      let new_withdrawal =\n        {value = amount, created = Chain.block_height}\n\n      put(state{withdraw_requests[caller] @ ws = new_withdrawal :: ws})\n\n\n  /**\n   * Withdraws tokens from ripe withdraw requests\n   */\n  stateful entrypoint\n    withdraw : () => tokens\n    withdraw() =\n      let caller = Call.origin\n      let (total_value, new_withdrawals) =\n        extract_ripe_withdrawals(state.withdraw_requests[caller])\n      \n      put(state{\n        stakes[caller] @ stakes = decrease_stake(stakes, total_value), \n        withdraw_requests[caller] = new_withdrawals})\n      Chain.spend(caller, total_value)\n      \n      total_value\n\n\n  /**\n   * Returns the leader of the upcoming generation without \n   * performing the election\n   */\n  entrypoint \n    get_computed_leader : () => option(delegate)\n    get_computed_leader() =\n      switch(state.last_election)\n        None     => None \n        Some(le) =>\n          if(Chain.block_height != le.height) None \n          else Some(le.leader)\n\n\n  /**\n   * Restricted. Performs the leader election.\n   */\n  stateful entrypoint\n    get_leader : hash => delegate\n    get_leader(rand) =\n      protocol_restrict()\n\n      switch(get_computed_leader())\n        Some(le) => le\n        None => \n          let candidates = get_candidates()\n          switch (elect_candidate(candidates, rand))\n            None => abort(\"NO_CANDIDATE\")\n            Some(leader) =>\n              reset_stake_age(leader)\n              set_leader(leader)\n              leader\n\n\n  /**\n   * Restricted. Vanishes the staked funds of the user in case of fraud\n   */\n  stateful entrypoint\n    punish : delegate => unit\n    punish(address) =\n      protocol_restrict()\n      let stake = staked_tokens(address)\n      put(state{stakes[address] = [], withdraw_requests[address] = []})\n"
  , "encodes":
    [ {"call": ["init", ["1", "2", "3"]], "calldata": "cb_KxFE1kQfOwIEBrCTAWU="}
    , {"call": ["deposit_stake", []], "calldata": "cb_KxGJnuzZP8x1nWE="}
    ]
  }
]
